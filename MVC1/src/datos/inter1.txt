Aplicación
de
Persistencia
Políglota
con
Sistemas
de
Almacenamiento
NoSQL
Estefanía
Gutiérrez
Pérez
Directora
Arantza
Illarramendi
Echave
Proyecto
Fin
de
Carrera
February
2014
Abstract
A
pesar
del
amplio
uso
de
los
sistemas
de
bases
de
datos
relacionales
el
gran
crecimiento
en
el
número
de
datos
digitalizados
disponibles
los
nuevos
requisitos
de
procesamiento
que
requieren
de
un
alta
disponibilidad
y
una
alta
escalabilidad
y
la
necesidad
creciente
de
manejar
grandes
volumenes
de
datos
por
parte
de
los
usuarios
ha
hecho
que
en
los
últimos
años
se
popularicen
los
llamados
sistemas
de
bases
de
datos
NOSQL
Sin
embargo
la
especialización
y
las
características
técnicas
de
estas
nuevas
tecnologías
hacen
que
algunos
sistemas
sean
más
adecuados
para
realizar
ciertas
tareas
que
otros
Ésto
unido
al
hecho
de
que
cada
vez
más
las
aplicaciones
y
servicios
realizan
tareas
más
diversas
sobre
los
datos
con
la
intención
de
ofrecer
a
los
usuarios
un
servicio
más
completo
ha
propiciado
la
aparición
de
la
idea
de
Aplición
de
persistencia
políglota
enfocada
al
uso
de
múltiples
sistemas
de
bases
de
datos
de
diferente
naturaleza
para
gestionar
los
datos
de
una
única
aplicación
Este
proyecto
trata
de
mostrar
las
ventajas
y
usos
de
varios
sistemas
NoSQL
y
así
mismo
de
mostrar
su
integración
sobre
una
única
aplicación
donde
se
intenta
que
cada
sistema
sea
utilizado
para
realizar
aquellas
tareas
para
las
cuales
esté
mejor
adaptado
Despite
the
popularity
of
relational
data
base
systems
the
high
growth
in
the
number
of
digitalize
data
the
new
processing
requeriments
that
ask
for
high
availability
and
scalability
of
data
and
the
growing
need
the
users
have
to
manage
large
volume
of
data
has
promote
the
use
of
so
called
NoSQL
databases
However
the
specialization
and
the
technical
characteristics
of
these
new
tecnologies
has
lead
to
the
fact
that
some
systems
are
better
when
performing
some
tasks
than
others
All
of
this
coupled
with
the
fact
that
more
and
more
applications
and
services
are
forming
different
tasks
on
the
data
with
the
idea
to
give
users
a
more
complete
service
has
contribute
to
the
emergence
of
the
concept
of
Poliglot
Persistence
Aplication
in
which
the
main
idea
is
the
use
of
multiple
and
diverse
database
systems
in
order
to
manage
the
data
of
one
application
This
project
tries
to
show
the
advantages
and
uses
of
various
NoSQL
systems
as
well
as
to
show
how
they
can
be
integrated
on
a
single
application
where
each
system
will
be
used
to
perform
the
tasks
for
which
it
is
best
suited
Agradecimientos
Gracias
a
Arantza
por
permitir
que
con
su
duro
trabajo
paciencia
y
consejos
fuera
posible
completar
con
éxito
este
proyecto
Gracias
también
a
mis
compañeros
por
sejarme
a
lo
largo
del
proyecto
en
especial
gracias
a
David
y
a
Alberto
Gracias
a
mi
familia
por
aconsejarme
para
que
finalizase
la
carrera
y
apoyarme
a
lo
largo
de
estos
años
Finalmente
gracias
a
todas
aquellas
personas
que
me
han
ayudo
o
creído
en
mi
ii
Contenidos
Abstract
i
Acknowledgements
ii
List
of
Figures
xi
List
of
Tables
xiii
1
Introducción
1
11
Objetivos




































1
12
Características
Generales
de
la
Aplicación
de
Persistencia
Políglota




2
121
Antecedentes






























3
122
Conceptos
Básicos



























4
123
Arquitectura






























5
13
Características
Generales
de
los
Sistemas
NoSQL














9
131
Antecedentes






























9
132
Conceptos
Básicos



























10
1321
Teorema
de
CAP























11
1322
Tipos
de
bases
de
datos
NoSQL














13
133
Porqué
NoSQL




























15
14
Planificación


































16
141
Alcance

































16
1411
Alcance
mínimo























17
14111
Aplicación
de
persistencia
políglota







17
14112
Diseño
del
entorno
de
trabajo











18
1412
Ampliación
del
alcance



















18
1413
Criterios
de
aceptación



















18
1414
Exclusiones
del
alcance



















19
142
Entregables
del
proyecto
























19
143
Esquema
de
desglose
de
trabajo




















19
144
Planificación
temporal

























20
1441
Actividades


























20
1442
Actividades
de
la
ampliación
















23
1443
Hitos





























23
145
Cronograma































24
146
Costes


































24
iii
Contenidos
iv
147
Análisis
de
calidad



























26
1471
Calidad
del
proyecto





















26
1472
Calidad
de
los
entregables


















26
148
Comunicaciones





























27
1481
Política
de
comunicación


















27
1482
Reuniones



























27
149
Gestión
de
riesgos



























27
2
Entorno
de
Trabajo
bajo
MongoDB
y
OpenLink
Virtuoso
30
21
MongoDB




































30
211
Herramientas






























32
212
Formato
de
los
datos


























33
213
Porqué
MongoDB


























33
214
Modelado
de
datos



























34
2141
Documentos

























34
21411
Restricciones
de
los
documentos
en
MongoDB

36
2142
Diseño





























36
2143
Patrones
de
diseño






















37
2144
Diseño
de
un
esquema
de
pruebas













38
21441
Diseño
1






















39
21442
Diseño
2






















40
215
Diseño
de
operaciones

























42
2151
Operaciones
CRUD





















43
21511
Operaciones
de
lectura















43
21512
Operaciones
de
escritura














51
21513
Métodos
para
cursores















61
2152
Entorno
de
agregación




















62
21521
Operadores





















63
21522
Secuencia
de
fases

















65
216
Índices


































66
2161
Tipos
de
índices























66
21611
Índices
de
un
sólo
campo













67
21612
Índices
compuestos

















67
21613
Índices
con
valor
múltiple













68
21614
Índices
text



















68
21615
TTL

























70
21616
Sparse
























70
2162
Diseño
de
índices























70
22
OpenLink
Virtuoso































73
221
Grafos


































74
222
Almacenamiento
de
las
tripletas




















75
223
Uso
del
sistema





























75
2231
Interfaz
Web

























75
2232
Línea
de
comandos






















76
224
Porqué
Virtuoso



























76
225
Modelado
de
datos



























77
2251
Diseño
Básico
de
un
grafo


















78
Contenidos
v
2252
Diseño
de
predicados




















79
2253
Diseño
del
esquema
de
pruebas















80
226
Diseño
de
operaciones

























81
2261
Operaciones
de
Lectura
SPARQL













81
22611
SELECT






















81
22612
GRAPH























82
22613
FILTER























83
22614
OPTIONAL




















84
22615
UNION























85
22616
Modificadores
de
resultados












85
22617
Funciones
de
agregación














86
22618
CONSTRUCT



















86
22619
ASK

























87
2262
Operaciones
de
Escritura
SPARQL













87
22621
DELETE






















87
22622
INSERT























87
22623
MODIFY






















88
2263
Operaciones
sobre
grafos


















88
22631
CREATE






















89
22632
CLEAR
y
DROP


















89
22633
COPY
























89
22634
MOVE























89
22635
ADD
























89
2264
Formato
de
salida
de
los
datos















90
2265
Funciones
dentro
de
SPARQL















90
22651
Ejemplo























90
2266
Funciones
Virtuoso
PL



















91
22661
Declaración
de
variables














92
2267
Sentencias
Condicionales


















92
22671
Sentencias
de
salto

















93
22672
Llamada
a
otros
métodos













93
22673
Sentencias
SPARQL
















93
22674
Uso
de
las
funciones
















93
2268
Reglas
de
inferencia





















94
22681
Ejemplo























95
227
Índices


































96
2271
Crear
índices

























97
2272
Eliminar
y
Alterar
índices


















97
3
Aplicación
de
Persistencia
Políglota
Diseño
98
31
Arquitectura


































98
311
Arquitectura
general


























98
312
Servicios

































99
313
Aplicación
Web





























104
32
Modelo
de
Casos
de
Uso




























105
3201
Ver
Contenidos
























106
32011
Caso
de
uso
Buscar
Artículo











106
Contenidos
vi
32012
Caso
de
uso
Ver
Artículo













107
32013
Caso
de
uso
Navegar















108
3202
Gestión
de
Cesta























109
32021
Caso
de
uso
Ver
Cesta














109
32022
Caso
de
uso
Modificar
Cesta











110
32023
Caso
de
uso
Añadir
a
Cesta











111
3203
Control
de
usuarios





















111
32031
Caso
de
uso
Identificarse













112
32032
Caso
de
uso
Registrarse













112
32033
Caso
de
uso
Desconectarse












113
3204
Clientes




























113
32041
Caso
de
uso
Realizar
Pedido











114
32042
Caso
de
uso
Ver
Pedido













115
32043
Caso
de
uso
Cancelar
Pedido










116
32044
Caso
de
uso
Ver
Compras












116
32045
Caso
de
uso
Ver
Valoraciones
del
Usuario




117
32046
Caso
de
uso
Eliminar
Valoraciones







117
32047
Caso
de
uso
Añadir
Valoración









117
32048
Caso
de
uso
Añadir
Like













118
33
Modelo
de
Datos
































118
331
Modelo
de
datos
en
MongoDB




















119
3311
Colección
Artículos





















119
3312
Colección
Carrito






















121
3313
Colección
Pedidos






















122
332
Modelo
de
datos
en
Virtuoso





















123
333
Modelo
de
datos
en
MySQL






















124
334
Relación
entre
los
datos
























125
34
Modelo
de
Clases
































125
341
Servicios

































125
3411
Clase
ConexVirtuoso





















127
3412
Clase
ConexMongoDB




















127
3413
Clase
ConexMySQL





















128
3414
Clase
ServicioUsers





















129
3415
Clase
ServicioValoraciones


















129
3416
Clase
ServicioCompras



















130
3417
Clase
ServicioRecomendaciones















131
3418
Clase
ServicioPedidos




















131
3419
Clase
ServicioCarrito




















132
34110
Clase
ServicioDatosArticulos
















133
34111
Clase
ServicioInventario



















134
342
Clases
de
Objetos




























135
3421
Clase
filtro


























137
3422
Clase
Par



























137
3423
Clase
Compra
























138
3424
Clase
Reviews
























138
3425
Clase
PedidoArt























138
3426
Clase
CarritoArt























139
Contenidos
vii
3427
Clase
Pedido

























139
34271
Clase
anidada
Pago
















140
34272
Clase
anidada
Envío
















140
3428
Clase
objArticle























140
34281
Clase
anidada
Precio
















140
3429
Clase
MovArtic
























141
34291
Clase
anidada
Detalles















141
34210
Clase
BookArtic























141
342101
Clase
anidada
Detalles















141
343
Clases
de
la
aplicación
Web






















141
3431
Clases
de
presentación




















143
3432
Clase
GestorBusqueda




















144
3433
Clase
GestorNavegarArt



















144
3434
Clase
GestorPresentacionArticulo













144
3435
Clase
GestorCesta






















145
3436
Clase
GestorClientes





















145
3437
Clase
GestorRecomendaciones















145
3438
Clase
GestorValoraciones


















146
3439
Clase
GestorPedidos





















146
4
Aplicación
de
Persistencia
Políglota
Implementación
147
41
Desarrollo
de
la
aplicación



























147
42
Estructura
de
la
aplicación



























148
43
Diagramas
de
secuencia




























150
44
Pruebas
de
errores































164
45
Tecnologías
de
Desarrollo



























166
451
Implementación
central
de
la
aplicación















166
4511
Java






























166
4512
J2EE





























167
4513
JSON
y
GSON
























167
452
Implementación
de
la
página
web



















168
4521
HTML
y
CSS

























168
4522
JavaScript
y
jQuery





















168
453
Pruebas

































168
4531
JUnit





























168
4532
Mozilla
Firefox
























169
454
Servidor
Web






























169
4541
Apache
Tomcat























169
455
Desarrollo
































169
4551
Netbeans



























169
456
Otros


































170
4561
FreeBase



























170
4562
Dropbox



























170
5
Aplicación
con
un
Sistema
Relacional
Comparación
171
51
Arquitectura


































171
52
Modelo
de
datos
































172
Contenidos
viii
521
Comparación
con
MongoDB






















172
522
Comparación
con
Virtuoso























174
523
Comparación
con
MySQL























175
53
Consultas




































175
531
Comparación
con
MongoDB






















176
532
Comparación
con
Virtuoso























177
54
Datos
en
la
aplicación





























179
541
Comparación
General

























179
542
Comparación
con
MongoDB






















180
55
Pruebas
de
rendimiento




























182
551
Preparación
de
los
Sistemas






















182
5511
MongoDB



























183
5512
Virtuoso



























183
5513
MySQL




























184
552
Preparación
de
las
pruebas






















184
553
Resultados































185
56
Conclusiones


































188
6
Extensión
a
un
Entorno
de
Trabajo
Distribuido
190
61
MongoDB




































190
611
Replicación































190
6111
Introducción

























191
6112
Inicio
de
los
servidores




















191
6113
Preparación
del
Sistema
de
Replicación










192
6114
Elecciones



























193
612
Sharding

































197
6121
Introducción

























197
6122
Inicio
de
las
servidores




















198
6123
Preparación
del
sistema



















199
62
OpenLink
Virtuoso































200
621
Replicación































201
6211
Introducción

























201
6212
Inicio
de
los
Servidores



















201
6213
Preparación
del
Sistema
de
Replicación










203
6214
Comportamiento























205
622
Sharding

































205
6221
Introducción

























205
6222
Preparación
del
sistema



















206
6223
Partición
de
los
índices



















209
7
Conclusiones
y
Líneas
Futuras
210
71
Conclusiones


































210
72
Líneas
Futuras

































211
73
Valoración
Personal































212
A
Manual
de
Instalación
213
Contenidos
ix
A1
Requisitos




































213
A2
MongoDB




































213
A21
Instalación
de
MongoDB
























214
A22
Configuración
de
usuarios























214
A3
Openlink
Virtuoso































215
A31
Instalación































215
A32
Configuración






























215
A4
MySQL





































217
A41
Instalación
de
Xampp

























217
A42
Configurar
de
MySQL

























219
A5
Oracle
Java



































222
A6
Apache
Tomcat

































223
A61
Instalación































223
A62
Configuración






























224
A7
Desplegar
la
aplicación





























225
B
Seguimiento
y
Control
226
B1
Desarrollo
de
los
Objetivos



























226
B2
Planificación
temporal





























227
B21
Actividades































227
B22
Actividades
de
la
ampliación





















232
B23
Hitos
y
replanificaciones
























233
C
MongoDB
Información
Adicional
236
C1
Instalación




































236
C11
Instalación
Básica



























236
C12
Inicio
de
la
instancia
del
servidor



















237
C13
Configuración






























237
C2
Control
de
usuarios































238
C21
Creación
de
un
administrador





















238
C22
Creación
del
resto
de
usuarios





















241
C23
Modificación
de
usuarios
























242
C3
Concurrencia


































242
C31
Ejemplo
1
































243
C32
Ejemplo
2
































244
C4
Transacciones


































246
C41
Operador
isolation


























247
C42
Método
findAndModify
























247
C43
Modificar
si
es
el
actual
























248
C5
Administración

































248
C51
Volcado
de
datos




























248
C511
Ejemplo




























249
C52
Recuperación
de
datos

























250
C6
Pruebas





































250
C61
Lectura

































251
C611
Diseño
1



























251
C612
Diseño
2



























253
Contenidos
x
C62
Escritura
































256
C621
Diseño
1



























256
C622
Diseño
2



























257
C63
Comparación






























258
D
OpenLink
Virtuoso
Información
Adicional
260
D1
Instalación




































260
D11
Instalación
Básica



























260
D2
Control
de
Usuarios






























261
D21
Creación
de
usuarios


























261
D22
Permisos
para
realizar
consultas
SPARQL














262
D23
Permisos
sobre
grafos

























263
D3
Concurrencia


































264
D4
Transacciones


































266
D5
Administración

































268
D51
Mejora
de
rendimiento

























268
D52
Dump
y
load
de
datos
RDF






















268
D521
Dump





























269
D522
Load





























269
D6
Pruebas





































270
D61
Lectura

































271
D62
Escritura
































273
E
Lista
de
entregables
275
E1
Entregables
relacionados
con
el
entorno
de
trabajo













275
E101
Documento
del
entrono



















275
E102
MongoDB



























275
E103
Virtuoso



























276
E2
Entregables
de
la
aplicación
políglota





















277
E21
Acceso
a
la
aplicación

























277
E22
Ejecutable
































278
E23
Código
Fuente
y
Javadoc























278
E231
Servicios



























278
E232
Aplicación
Principal




















279
E24
Tabla
de
Inventario



























279
E3
Entregables
de
la
aplicación
relacional




















280
E31
Acceso
a
la
aplicación

























280
E32
Ejecutable
































280
E33
Código
Fuente
y
Javadoc























280
E34
Datos
MySQL





























281
E4
Otros






































281
Bibliography
284
Lista
de
figuras
11
Ejemplo
de
una
arquitectura
con
un
único
sistema
de
almacenamiento


5
12
Arquitectura
para
una
Aplicación
de
Persistencia
Políglota
Diseño
I



6
13
Arquitectura
para
una
Aplicación
de
Persistencia
Políglota
Diseño
II


7
14
Arquitectura
para
una
Aplicación
de
Persistencia
Políglota
Diseño
III


8
15
Datos
estructurados
vs
no
estructurados
[1]

















10
16
Sistema
de
Bases
de
Datos
Basado
en
Documentos













13
17
Sistema
de
Bases
de
Datos
Basado
en
Grafos
















14
18
Sistema
de
Bases
de
Datos
Basado
en














14
19
Sistema
de
Bases
de
Datos
Basado
en
Familia
de
columnas









15
110
Esquema
de
desglose
de
trabajo
























20
111
Cronograma



































25
31
Distribución
de
los
servicios


























103
32
Arquitectura
en
Tres
Capas


























105
33
Casos
de
usos
Ver
Contenidos
























106
34
Casos
de
usos
Gestión
de
Cesta























109
35
Casos
de
usos
Control
de
usuarios






















111
36
Casos
de
usos
Operaciones
para
Clientes


















114
37
Modelo
de
datos
en
MongoDBa
artículos
b
carritos
c
pedidos



119
38
Modelo
de
datos
en
Virtuoso

























124
39
Modelo
de
datos
en
MySQL


























124
310
Diagrama
de
Clases
Servicios

























126
311
Clase
ConexVirtuoso





























127
312
Clase
ConexMongoDB




























128
313
Clase
ConexMySQL






























128
314
Clase
ServiciosUsers






























129
315
Clase
ServicioValoraciones


























130
316
Clase
ServicioCompras




























130
317
Clase
ServicioRecomendaciones
























131
318
Clase
ServicioPedidos





























132
319
Clase
ServicioCarrito





























133
320
Clase
ServicioDatosArticulos

























134
321
Clase
ServicioDatosArticulos

























135
322
Modelos
de
Clases
Objetos


























136
323
Clase
Par




































137
324
Diagrama
de
ClasesAplicación
Central




















142
41
Estructura
de
la
aplicación



























149
xi
Lista
de
Figures
xii
42
Diagrama
de
secuencia
del
caso
de
uso
Navegar















151
43
Diagrama
de
secuencia
del
caso
de
uso
Buscar
Artículo











152
44
Diagrama
de
los
casos
de
uso
Ver
Cesta



















152
45
Diagrama
de
secuencia
del
caso
de
uso
Ver
Artículo
I











153
46
Diagrama
de
secuencia
del
caso
de
uso
Ver
Artículo
II










154
47
Diagrama
de
secuencia
del
caso
de
uso
Insertar
en
Cesta










155
48
Diagrama
de
secuencia
del
caso
de
uso
modificar
Cesta
eliminar
artículo

155
49
Diagrama
de
secuencia
del
caso
de
uso
modificar
Cesta
II
modificar
cantidad
de
un
artículo





























156
410
Diagrama
de
secuencia
del
caso
de
uso
Registrarse













157
411
Diagrama
de
secuencia
del
caso
de
uso
Login
















158
412
Diagrama
de
secuencia
del
caso
de
uso
Desconectarse












159
413
Diagrama
de
secuencia
del
caso
de
uso
Ver
Pedidos
del
usuario






159
414
Diagrama
de
secuencia
del
caso
Ver
Compras
del
cliente










159
415
Diagrama
de
secuencia
del
caso
Ver
Valoraciones
de
los
Usuarios





160
416
Diagrama
de
secuencia
del
caso
de
uso
Eliminar
Valoración








160
417
Diagrama
de
secuencia
del
caso
de
uso
Añadir
Valoración









160
418
Diagrama
de
secuencia
del
caso
de
uso
Realizar
Pedido
I









161
419
Diagrama
de
secuencia
del
caso
de
uso
Realizar
Pedido
II








162
420
Diagrama
de
secuencia
del
caso
de
uso
Realizar
Pedido
III








163
421
Diagrama
de
los
casos
de
uso
Cancelar
Pedido
















164
51
Modelo
de
datos
para
MySQL

























173
A1
Identificarse
en
la
interfaz
web
de
Virtuoso


















216
A2
Crear
un
usuario
I






























216
A3
Crear
un
usuario
II






























217
A4
Instalar
Xampp

































218
A5
Finalizar
Instalación
Xampp


























218
A6
Acceder
a
phpMyAdmin




























219
A7
Crear
una
Base
de
datos
en
MySQL





















220
A8
Configurar
usuario
de
la
base
de
datos
en
MySQL
I












220
A9
Configurar
usuario
de
la
base
de
datos
en
MySQL
II











221
A10
Configurar
usuario
de
la
base
de
datos
en
MySQL
III











221
A11
Crear
tabla
inventario
I



























222
A12
Crear
tabla
inventario
II



























222
A13
Desplegar
archivo
war





























225
Lista
de
Tablas
11
Tiempo
de
planificación
estimado























20
12
Tiempo
de
getión
estimado


























21
13
Tiempo
de
formación
estimado
























21
14
Tiempo
de
desarrollo
estimado
























22
15
Tiempo
de
documentación
estimado





















22
16
Estimación
del
tiempo
de
la
ampliación



















23
17
Fecha
de
Hitos

































24
51
Comparación
del
rendimiento
entre
aplicaciones















186
52
Comparación
del
rendimiento
entre
aplicaciones
II












188
B1
Tiempo
de
planificación
estimado
y
real



















228
B2
Tiempo
de
gestión
estimado
y
real






















228
B3
Tiempo
de
formación
estimado
y
real





















229
B4
Tiempo
de
desarrollo
estimado
y
real





















230
B5
Tiempo
de
documentación
estimado
y
real


















231
B6
Estimación
del
tiempo
de
la
ampliación
y
real
















232
B7
Fecha
de
Hitos

































233
B8
Fecha
de
Hitos
segunda
replanificación




















235
xiii
Capítulo
1
Introducción
En
este
capítulo
se
va
a
hablar
de
los
objetivos
principales
del
proyecto
y
de
las
terístias
de
las
principales
tecnologías
involucradas
en
el
proyecto
11
Objetivos
En
los
últimos
años
se
han
popularizado
los
sistemas
de
bases
de
datos
NoSQL
y
con
ellos
recientemente
ha
surgido
la
idea
de
Aplicación
de
Persistencia
Políglota
Ésta
sostiene
que
debido
a
la
gran
variedad
y
cantidad
de
datos
y
los
diversos
servicios
que
pueden
dar
las
aplicaciones
hoy
en
día
es
posible
que
un
único
tipo
de
sistema
de
almacenamiento
no
sea
capaz
de
cubrir
de
forma
eficiente
todas
las
necesidades
de
la
aplicación
que
use
dicho
sistema
Sin
embargo
sostiene
que
las
aplicaciones
se
pueden
beneficiar
del
uso
de
varios
sistemas
de
distinto
tipo
donde
los
datos
se
repartirían
entre
los
sistemas
que
mejor
fueran
capaces
de
dar
acceso
a
estos
en
función
del
tipo
de
datos
y
de
las
tareas
que
se
realizarán
con
ellos
Además
con
esta
idea
también
se
considera
que
se
tiene
que
ir
más
allá
de
los
sistemas
de
almacenamiento
relacionales
y
utilizar
además
sistemas
de
almacenamiento
NoSQL
El
objetivo
de
este
proyecto
por
tanto
es
el
de
crear
una
Aplicación
de
Persistencia
Políglota
que
permita
interactuar
con
varios
tipos
de
sistemas
de
bases
de
datos
siendo
la
interacción
con
los
diferentes
sistemas
lo
más
transparente
posible
Al
mismo
tiempo
también
es
objetivo
del
proyecto
aprender
manejar
y
diseñar
un
entorno
de
trabajo
para
dos
sistemas
de
bases
de
datos
NoSQL
Para
lograr
esto
en
este
proyecto
se
han
llevado
a
cabo
dos
tareas
principales
1
por
un
lado
se
ha
hecho
un
estudio
de
dos
sistemas
de
almacenamiento
NOSQL
de
distinto
1
Introducción
2
tipo
MongoDB
y
OpenLink
Virtuoso
y
2
se
ha
creado
una
aplicación
web
que
usa
estos
dos
sistemas
junto
a
un
sistema
relacional
Para
el
primer
punto
se
ha
escrito
un
documento
cuyo
contenido
se
encuentra
en
los
siguientes
capítulos
de
la
memoria
pero
también
se
puede
encontrar
en
un
documento
separado
donde
se
detallan
las
características
y
la
forma
en
la
que
se
usan
los
dos
sistemas
Este
documento
está
orientado
a
personas
que
tienen
conocimientos
de
sistemas
relacionales
y
se
intenta
explicar
cómo
en
los
sistemas
no
relacionales
se
llevarían
a
cabo
ciertas
tareas
que
se
pueden
hacer
en
los
sistemas
relacionales
si
es
posible
hacerlas
En
concreto
se
centra
entre
otros
detalles
en
explicar
aspectos
referentes
al
control
de
usuario
modelado
de
datos
índices
concurrencia
y
transacciones
y
las
diferentes
formas
en
las
que
se
pueden
realizar
las
consultas
Además
se
han
generado
varios
datasets
para
cada
sistema
con
los
que
seguir
la
documentación
parte
de
los
datos
de
estos
datasets
serán
reutilizados
para
la
parte
de
la
aplicación
Para
el
segundo
punto
se
ha
desarrollado
una
aplicación
que
gestiona
una
tienda
nica
la
cual
hace
uso
de
varios
sistemas
de
almacenamiento
Se
presentarán
los
distintos
problemas
que
surgen
durante
su
diseño
e
implementación
y
las
diferentes
soluciones
que
se
pueden
adoptar
Finalmente
en
este
documento
se
intenta
1
dar
una
idea
general
de
los
sistemas
de
almacenamiento
NoSQL
y
de
las
Aplicaciones
de
Persistencia
Políglota2
dar
mación
concreta
del
funcionamiento
y
configuración
de
los
sistemas
NoSQL
MongoDB
y
OpenLink
Virtuoso
3
mostrar
las
diferentes
decisiones
de
diseño
e
implementación
llevadas
a
cabo
para
realizar
la
aplicación
y
4
realizar
una
comparación
con
una
cación
que
sólo
utilice
un
sistema
relacional
Para
este
último
punto
se
ha
creado
una
aplicación
idéntica
reutilizando
la
mayor
parte
del
código
pero
únicamente
se
vale
del
sistema
relacional
de
almacenamiento
MySQL
La
comparación
de
estás
dos
ciones
se
ha
basado
tanto
a
nivel
de
diseño
como
a
nivel
de
rendimiento
Cabe
destacar
que
la
información
de
diseño
e
implementación
de
esta
segunda
aplicación
está
orientada
a
la
comparación
con
la
aplicación
original
y
por
tanto
no
se
entra
en
los
detalles
de
la
implementación
o
del
diseño
no
orientados
a
la
que
en
su
mayoría
serán
similares
a
los
da
la
aplicación
original
12
Características
Generales
de
la
Aplicación
de
cia
Políglota
En
esta
sección
se
va
a
explicar
en
qué
consiste
una
Aplicación
de
Persistencia
Políglota
y
cuales
son
sus
posibles
beneficios
frente
a
otras
aplicaciones
más
tradicionales
Introducción
3
121
Antecedentes
La
tendencia
de
muchas
empresas
al
desarrollar
una
aplicación
es
la
de
utilizar
un
único
sistema
de
almacenamiento
para
guardar
los
datos
independientemente
de
las
ciones
que
hagan
con
ellos
[2]
En
ciertos
casos
las
aplicaciones
son
sencillas
y
realizan
una
operación
concreta
o
varias
muy
relacionadas
con
lo
que
el
uso
de
un
único
sistema
de
bases
de
datos
no
sería
problemático
Sin
embargo
cada
vez
más
se
ve
a
las
aplicaciones
como
un
servicio
que
puede
realizar
gran
variedad
de
tareas
bien
por
la
naturaleza
misma
del
servicio
o
porque
se
quiere
enriquecer
la
experiencia
del
usuario
Por
ejemplo
la
llamadas
redes
sociales
donde
el
usuario
crea
contenido
propios
mantiene
comunicaciones
con
otros
usuarios
con
los
que
tiene
alguna
relación
recibe
publicidad
personalizada
Estas
aplicaciones
más
complejas
realizan
diferentes
tareas
sobre
distintos
tipos
de
datos
En
este
caso
el
uso
de
un
único
sistema
de
bases
de
datos
puede
evitar
que
se
obtenga
un
buen
rendimiento
[2]
puesto
que
cada
tipo
de
datos
y
las
operaciones
que
se
quieren
realizar
sobre
estos
tienen
distintas
necesidades
Por
ejemplo
la
información
sobre
los
artículos
de
un
comercio
no
tendrá
las
mismas
propiedades
o
necesidades
de
consistencia
que
la
información
sobre
la
disponibilidad
de
los
artículos
Para
una
misma
aplicación
es
posible
que
se
quieran
tener
unos
ciertos
datos
que
estén
disponibles
en
el
menor
tiempo
posible
independientemente
de
si
todos
los
usuarios
pueden
ver
los
datos
introducidos
hace
un
segundo
Otros
querrán
que
los
datos
sean
siempre
consistentes
otros
que
estén
altamente
relacionados
entre
ellos
Todo
esto
resulta
ser
problemático
al
usar
una
única
base
de
datos
debido
a
que
distintos
sistemas
de
bases
de
datos
están
diseñados
para
resolver
distintos
problemas
Ésto
hace
que
los
sistemas
de
almacenamiento
que
sean
buenos
para
una
única
tarea
no
sean
la
mejor
solución
para
otra
Debido
a
esto
y
junto
con
la
popularización
de
los
sistemas
NoSQL
surge
la
idea
de
utilizar
varios
sistemas
de
bases
de
datos
de
diferente
tipo
en
una
misma
aplicación
Lo
que
se
busca
al
usar
varios
sistemas
al
mismo
tiempo
es
que
se
dividan
los
datos
entre
los
distintos
sistemas
en
función
de
las
necesidades
de
los
datos
y
las
tareas
que
hagan
uso
de
dichos
datos
Todo
esto
con
la
idea
de
que
el
sistema
usado
sea
el
mejor
posible
en
cada
caso
para
cubrir
dichas
necesidades
Introducción
4
122
Conceptos
Básicos
El
termino
Aplicación
de
Persistencia
Políglota
describe
la
idea
de
que
las
aplicaciones
deberían
utilizar
diferentes
sistemas
de
bases
de
datos
al
mismo
tiempo
pensando
en
que
se
utilice
el
sistema
de
bases
de
datos
más
adecuado
para
cada
tarea
Esto
se
debe
a
que
como
se
ha
indicado
antes
algunos
tipos
de
bases
de
datos
están
mejor
diseñadas
para
realizar
ciertas
tareas
que
otros
En
lugar
de
decidir
usar
un
sistema
que
cubra
las
necesidades
de
una
de
las
tareas
y
que
el
resto
de
datos
y
tareas
se
adapten
al
sistema
usado
se
busca
que
los
sistemas
se
adapten
a
la
aplicación
Es
decir
lo
que
se
busca
con
este
tipo
de
aplicaciones
es
que
primero
se
decida
qué
tareas
se
van
a
realizar
con
qué
tipo
de
datos
y
cuales
serán
sus
necesidades
y
después
elegir
el
sistema
que
mejor
se
adapte
a
las
necesidades
de
cada
tarea
De
esta
forma
se
tendrán
varios
sistemas
de
bases
de
datos
para
cada
aplicación
Por
ejemplo
suponiendo
que
se
quiere
implementar
una
red
social
básica
con
la
mación
de
los
usuarios
y
además
con
información
sobre
sus
actividades
y
las
de
sus
amigos
si
se
utiliza
un
diseño
simple
con
un
único
sistema
de
almacenamiento
se
guardará
en
éste
la
información
de
los
usuarios
la
cual
puede
incluir
tanto
los
datos
personales
como
el
contenido
creado
por
ellos
mismos
Y
en
el
mismo
sistema
habría
que
guardar
la
información
sobre
las
relaciones
que
tiene
con
otros
usuarios
Sin
embargo
si
se
utilizan
varios
sistemas
se
podría
por
ejemplo
guardar
la
información
personal
y
los
datos
de
los
contenidos
en
un
sistema
de
familia
de
columnas
o
de
mentos
que
permita
representar
datos
complejos
Y
por
otro
lado
las
relaciones
de
los
usuarios
y
sus
acciones
en
un
sistema
de
grafos
que
permite
almacenar
datos
altamente
relacionados
de
forma
simple
De
esta
forma
si
la
aplicación
necesitase
generar
recomendaciones
basadas
en
los
gustos
de
sus
amigos
podría
utilizar
la
base
de
datos
de
grafos
Y
si
se
quiere
visualizar
la
página
del
usuario
se
podría
usar
el
otro
sistema
para
obtener
los
datos
de
los
contenidos
creados
El
principal
problema
a
la
hora
de
crear
este
tipo
de
aplicación
es
que
debe
comunicarse
con
sistemas
de
bases
de
datos
diferentes
Por
lo
que
en
principio
ésto
podría
hacer
que
la
aplicación
fuera
muy
compleja
En
el
siguiente
punto
se
muestran
las
diferentes
opciones
que
se
pueden
seguir
al
diseñar
este
tipo
de
aplicaciones
y
como
evitar
en
parte
dicha
complejidad
Introducción
5
123
Arquitectura
Uno
de
los
puntos
más
interesantes
en
las
Aplicaciones
de
Persistencia
Políglota
además
de
los
sistemas
de
almacenamiento
en
si
es
la
forma
en
la
que
se
debería
estructurar
la
aplicación
La
presencia
de
varios
sistemas
de
almacenamiento
trae
consigo
una
serie
de
problemas
y
necesidades
que
no
existen
en
las
aplicaciones
con
un
único
sistema
de
almacenamiento
En
una
aplicación
simple
se
tendría
un
único
sistema
al
cual
se
accedería
para
realizar
las
diferentes
operaciones
independientemente
de
qué
tarea
se
trate
o
qué
datos
se
quieran
consultar
Por
tanto
tal
y
como
se
muestra
en
la
figura
11
la
aplicación
realiza
ciones
que
necesitan
hacer
diferentes
consultas
pero
todas
ellas
se
hacen
sobre
el
mismo
sistema
de
almacenamiento
Figura
11
Ejemplo
de
una
arquitectura
con
un
único
sistema
de
almacenamiento
Al
introducir
nuevos
sistemas
de
almacenamiento
la
aplicación
deberá
realizar
las
sultas
de
los
datos
sobre
distintos
sistemas
Esto
genera
nuevas
cuestiones
sobre
cómo
diseñar
la
arquitectura
Es
necesario
que
la
aplicación
central
sepa
que
hay
varios
temas
Es
posible
que
el
uso
de
varios
sistemas
sea
transparente
Qué
ocurre
cuando
se
cambia
uno
de
los
sistemas
o
se
añade
uno
nuevo
Teniendo
en
cuenta
estas
cuestiones
y
los
posibles
escenarios
que
se
pueden
presentar
se
observa
que
existen
diferentes
ciones
de
diseño
que
se
pueden
tomar
En
general
la
elección
de
qué
diseño
usar
vendrá
dada
por
las
necesidades
de
cada
aplicación
Un
primer
diseño
sería
el
más
directo
En
este
caso
cada
parte
de
la
aplicación
se
nica
directamente
con
el
sistema
de
almacenamiento
que
contiene
los
datos
a
los
que
se
quiere
acceder
Tal
y
como
se
puede
ver
en
la
figura
12
la
aplicación
realiza
operaciones
Introducción
6
sobre
cada
uno
de
los
sistemas
de
almacenamiento
según
lo
vea
necesario
En
principio
este
diseño
genera
varios
problemas
pero
uno
de
los
principales
es
que
la
presencia
de
las
tres
bases
de
datos
no
es
transparente
para
la
aplicación
Figura
12
Arquitectura
para
una
Aplicación
de
Persistencia
Políglota
Diseño
I
El
segundo
diseño
intenta
eliminar
los
problemas
anteriores
La
idea
es
envolver
las
bases
de
datos
en
servicios
de
forma
que
las
aplicaciones
no
se
comuniquen
directamente
con
los
sistemas
de
almacenamiento
[2]
Éstas
se
comunicarán
con
los
servicios
Éstos
servicios
serán
los
encargados
de
realizar
las
consultas
sobre
las
bases
de
datos
Con
esto
por
un
lado
se
consigue
1
que
la
distribución
de
los
datos
entre
diferentes
sistemas
de
almacenamientos
sea
transparente
para
la
aplicación
y
2
que
los
servicios
puedan
ser
reutilizados
por
otras
aplicaciones
que
necesiten
acceder
a
esos
datos
Por
tanto
una
arquitectura
con
este
diseño
tendría
una
forma
similar
al
de
la
figura
13
Siguiendo
la
idea
anterior
del
uso
de
servicios
se
puede
considerar
que
hay
dos
posibles
opciones
de
diseño
Por
un
lado
se
podría
tener
un
servicio
por
cada
base
de
datos
Por
ejemplo
si
en
un
sistema
de
documentos
se
guardan
datos
sobre
los
artículos
de
un
comercio
y
sobre
la
cesta
de
la
compra
se
podría
tener
un
servicio
que
se
encargara
de
realizar
consultas
tanto
sobre
los
datos
de
los
artículos
como
de
las
cestas
tal
y
como
se
muestra
en
la
figura
anterior
13

Aunque
el
diseño
anterior
es
perfectamente
valido
existen
algunas
cuestiones
sin
resolver
Si
por
ejemplo
se
quisiera
utilizar
un
nuevo
sistema
de
almacenamiento
para
guardar
la
información
de
la
cesta
En
este
caso
además
de
crear
el
nuevo
servicio
habría
que
modificar
todo
el
servicio
que
envolvía
el
sistema
de
documentos
el
cual
contenía
a
las
cestas
Otro
problema
que
surge
si
se
ponen
varios
objetos
sobre
un
mismo
servicio
es
que
acceder
a
los
servicios
desde
una
segunda
aplicación
puede
resultar
algo
complejo
Por
Introducción
7
Figura
13
Arquitectura
para
una
Aplicación
de
Persistencia
Políglota
Diseño
II
ejemplo
si
se
quisiese
acceder
a
los
datos
de
los
artículos
desde
una
segunda
aplicación
pero
no
dar
acceso
a
los
datos
de
las
cestas
sería
necesario
por
ejemplo
crear
un
servicio
especial
que
sirviera
como
puente
entre
el
servicio
anterior
y
la
aplicación
Por
tanto
una
segunda
opción
de
un
diseño
basado
en
servicios
es
crear
servicios
en
función
de
los
datos
que
se
guardan
y
no
en
función
de
los
sistemas
De
esta
forma
si
se
quiere
utilizar
un
sistema
de
almacenamiento
de
tipo
para
guardar
la
cesta
sólo
se
tendría
que
modificar
el
servicio
encargado
de
la
cesta
y
no
el
de
los
artículos
Así
la
arquitectura
tendría
la
forma
que
se
muestra
en
la
figura
14
donde
ahora
hay
dos
servicios
que
usan
un
mismo
sistema
de
almacenamiento
Cualquiera
de
los
diseños
anteriores
es
perfectamente
valido
todo
depende
de
si
se
tiene
pensado
reutilizar
las
consultas
o
se
van
a
añadir
o
modificar
los
sistemas
de
bases
de
datos
en
el
futuro
Finalmente
una
vez
definida
la
estructura
base
de
la
arquitectura
un
punto
importante
a
tener
en
cuenta
es
la
forma
en
la
que
se
repartirán
los
datos
Como
se
comento
antes
la
idea
de
crear
una
aplicación
de
estas
características
es
que
se
guarden
los
datos
en
los
sistemas
de
almacenamiento
que
mejor
se
adecuen
a
los
datos
y
a
los
usos
que
se
van
a
hacer
de
ellos
Cada
caso
es
diferente
y
cada
sistema
de
almacenamiento
dentro
de
un
mismo
tipo
tiene
una
serie
de
características
que
le
pueden
hacer
más
o
menos
Introducción
8
Figura
14
Arquitectura
para
una
Aplicación
de
Persistencia
Políglota
Diseño
III
adecuado
Sin
embargo
una
primera
distribución
de
los
datos
en
función
del
tipo
de
almacenamiento
se
podría
hacer
teniendo
en
cuenta
lo
siguiente

Datos
complejos
si
los
datos
que
se
van
a
almacenar
tienen
una
estructura
pleja
de
varios
niveles
y
se
quiere
mantener
una
estructura
similar
para
los
objetos
que
estén
en
las
bases
de
datos
y
los
que
esten
en
las
aplicaciones
En
este
caso
debido
a
su
flexibilidad
y
al
formato
en
que
se
guardan
los
datos
tanto
los
sistemas
de
Documentos
como
los
de
Familias
de
Columnas
son
adecuados
para
almacenar
este
tipo
de
datos

Datos
altamente
entrelazados
si
los
datos
que
se
van
a
guardar
tienen
gran
número
de
relaciones
entre
ellos
y
se
quiere
conocer
esta
relación
de
forma
precisa
En
este
caso
los
sistemas
de
grafos
están
mejor
adaptados
para
representar
datos
donde
prima
conocer
las
relaciones
entre
ellos
y
además
son
más
eficientes
que
otros
sistemas
a
la
hora
de
realizar
consultas
en
función
de
estas
relaciones

Datos
consistentes
si
los
datos
necesitan
ser
consistentes
en
todo
momento
para
todos
los
usuarios
En
este
caso
algunos
sistemas
como
los
de
grafos
cumplen
con
los
principios
ACID
para
mantener
la
consistencia
de
los
datos
sin
embargo
otros
sistemas
como
los
relacionales
presentan
herramientas
sencillas
que
permiten
controlar
las
transacciones
y
los
bloqueos

Datos
modificados
frecuentemente
si
los
datos
van
a
ser
modificados
y
leídos
de
forma
frecuente
quieren
ser
accedidos
en
tiempo
real
y
cada
acceso
sólo
calee
una
pequeña
parte
de
los
datos
Si
estos
no
requieren
de
una
estructura
con
muchos
niveles
de
anidamiento
no
más
de
tres
la
mejor
opción
son
los
sistemas
de
tipo
los
cuales
permiten
acceder
de
forma
muy
eficiente
a
los
datos
Introducción
9
13
Características
Generales
de
los
Sistemas
NoSQL
En
esta
sección
se
va
a
intentar
mostrar
una
idea
básica
del
uso
de
las
tecnologías
NoSQL
y
sus
posibles
beneficios
con
respecto
a
otros
sistemas
de
almacenamiento
131
Antecedentes
Durante
muchos
años
los
sistemas
de
bases
de
datos
relacionales
han
sido
el
sistema
preferido
para
el
almacenamiento
de
datos
digitales
Sin
embargo
si
bien
no
es
una
tecnología
nueva
en
los
últimos
años
la
popularidad
de
los
sistemas
de
bases
de
datos
NoSQL
ha
crecido
[3
4]
en
gran
medida
Existen
varios
factores
que
han
propiciado
dicha
popularidad
Uno
de
ellos
ha
sido
la
adopción
yo
desarrollo
de
este
tipo
de
sistemas
por
parte
de
grandes
empresas
como
Google
BigTable
Amazon
SimpleDB
o
Facebook
Cassandra
entre
otras
Todo
esto
ha
ayudado
tanto
a
popularizar
los
sistemas
de
cara
a
los
usuarios
como
a
inspirar
el
desarrollo
de
otros
sistemas
similares
generando
con
ello
un
gran
número
de
opciones
en
el
mercado
Otros
factores
han
sido
el
surgimiento
de
nuevos
problemas
derivados
del
aumento
de
los
datos
digitalizados
la
variedad
de
los
datos
y
del
uso
que
se
hace
de
ellos
Con
la
constante
aparición
de
nuevas
tecnologías
y
el
alto
uso
de
internet
cada
vez
es
más
sencillo
obtener
y
almacenar
datos
lo
cual
ha
provocado
que
aumente
drásticamente
la
cantidad
de
datos
disponibles
[5]
y
es
cada
vez
más
común
encontrar
aplicaciones
y
servicios
que
utilicen
grandes
conjuntos
de
datos
Big
Data
Ésto
hace
que
se
deban
tener
los
recursos
necesarios
tanto
para
almacenar
los
datos
como
para
poder
procesarlos
Generalmente
en
los
sistemas
relacionales
se
tendía
a
mejorar
el
rendimiento
a
través
del
escalonamiento
mejorando
el
hardware
de
los
ordenadores
pero
con
un
gran
número
de
datos
escalar
el
hardware
resulta
complicado
yo
costoso
con
lo
que
se
hace
necesario
repartir
la
carga
de
trabajo
entre
varios
ordenadores
Si
bien
los
sistemas
relacionales
son
capaces
de
distribuir
los
datos
no
están
diseñados
para
ser
distribuidos
y
resulta
complejo
realizar
consultas
entre
tablas
que
estén
distribuidas
en
varios
sistemas
[6]
Con
el
aumento
del
número
de
datos
también
ha
aumentado
la
complejidad
y
estructuración
de
estos
Algunos
datos
como
la
información
de
una
hoja
de
cálculo
son
simples
y
pueden
ser
representados
fácilmente
mediante
las
tablas
de
los
esquemas
relacionales
Otros
datos
más
complejos
que
representan
objetos
que
contienen
objetos
o
datos
altamente
relacionados
como
la
información
sobre
relaciones
entre
personas
social
graphs
resultan
complicados
de
representar
en
un
sistema
relacional
Si
bien
es
posible
Introducción
10
hacerlo
el
esquema
resultante
podría
contener
varias
tablas
relacionadas
que
requerirían
de
JOINs
complejos
para
obtener
los
datos
Además
de
la
complejidad
cada
vez
más
objetos
similares
pueden
tener
características
distintas
y
carecer
de
una
estructura
concreta
con
lo
que
cada
objeto
puede
tener
un
esquema
diferente
Por
esto
en
ciertos
casos
se
busca
un
sistema
flexible
que
permita
adaptar
el
esquema
fácilmente
a
las
distintas
estructuras
de
los
datos
de
forma
dinámica
Figura
15
Datos
estructurados
vs
no
estructurados
[1]
Estos
problemas
han
hecho
que
se
busque
en
los
sistemas
NoSQL
una
alternativa
a
los
sistemas
tradicionales
de
bases
de
datos
relacionales
los
cuales
no
estaban
específicamente
adaptados
a
estos
problemas
132
Conceptos
Básicos
Pese
a
su
nombre
las
bases
de
datos
NoSQL
no
hacen
referencia
a
bases
de
datos
que
no
utilizan
SQL
sino
que
el
término
se
refiere
a
las
bases
de
datos
que
no
utilizan
un
modelos
relacional
para
modelar
los
datos
que
estén
almacenados
en
estas
Para
los
sistemas
NoSQL
este
modelo
no
es
único
y
se
pueden
distinguir
varios
tipos
de
sistemas
dependiendo
de
cómo
abordan
este
problema
Más
adelante
[pag15]
se
hablará
de
los
principales
tipos
de
sistemas
Los
sistemas
de
bases
de
datos
NoSQL
generalmente
están
diseñados
pensando
en
que
se
usarán
para
el
almacenamiento
distribuido
de
un
gran
conjunto
de
datos
y
con
la
idea
de
que
sean
fácilmente
escalables
mediante
la
distribución
de
sus
datos
entre
distintos
ordenadores
o
servidores
clusters
Introducción
11
Una
de
las
características
principales
y
ventaja
frente
a
sistemas
relacionales
es
que
estos
sistemas
manejan
datos
no
estructurados
como
emails
archivos
multimedia
o
grafos
sociales
de
forma
muy
eficiente
[6]
Esto
se
debe
a
que
estos
sistemas
almacenan
los
datos
sin
esquemas
schemaless
En
teoría
según
esta
característica
los
datos
almacenados
no
deben
seguir
ningún
tipo
de
esquema
prefijado
Si
bien
esto
es
cierto
en
la
realidad
y
debido
en
parte
al
uso
que
se
hará
de
los
datos
siempre
habrá
algún
tipo
de
esquema
prefijado
el
cual
se
ajuste
a
las
necesidades
de
la
aplicación
que
utiliza
dichos
datos
Sin
embargo
es
posible
insertar
nuevos
objetos
que
tengan
un
esquema
distinto
al
de
los
datos
ya
insertados
sin
que
se
tengan
que
las
estructuras
tablas
colecciones
grafos
familias
de
columnas
que
guarda
dichos
objetos[2]
Un
detalle
a
tener
en
cuenta
es
que
si
bien
en
general
las
bases
de
datos
no
relacionales
están
orientadas
a
su
uso
en
clusters
algunas
bases
de
datos
como
las
de
grafos
utilizan
un
modelo
distribuido
similar
al
de
las
bases
de
datos
relacionales
con
lo
que
se
tendrían
problemas
similares
al
escalar
sobre
varios
ordenadores
o
servidores
Sin
embargo
el
modelo
de
datos
de
estas
bases
de
datos
es
mejor
para
manejar
datos
con
relaciones
complejas[2]
Así
mismo
otros
sistemas
no
relacionales
más
adaptados
para
su
uso
en
clusters
con
la
intención
de
escalar
los
datos
pueden
no
resultar
tan
eficientes
al
tratar
datos
altamente
relacionados
[7]
Finalmente
un
punto
importante
es
que
la
mayoría
de
los
sistemas
no
relacionales
no
respetan
los
principios
ACID
atomicidad
consistencia
aislamiento
y
durabilidad
Pese
a
que
este
principio
parece
imprescindible
para
llevar
a
cabo
tareas
con
los
datos
nados
resultan
incompatible
con
la
alta
disponibilidad
y
eficiencia
en
el
uso
de
grandes
conjuntos
de
datos
que
se
espera
de
los
sistemas
NoSQL
Ésto
se
debe
principalmente
a
los
problemas
planteados
por
el
teorema
de
CAP
de
Brewer
[8]
y
las
soluciones
tadas
por
los
sistemas
que
dan
prioridad
a
la
disponibilidad
y
la
eficiencia
antes
que
a
la
consistencia
Seguidamente
se
explica
el
Teorema
de
CAP
y
las
soluciones
planteadas
a
los
problemas
entre
ellas
el
principio
BASE
1321
Teorema
de
CAP
En
el
2000
Brewer
dio
una
conferencia
en
la
que
planteaba
los
tres
requerimientos
cipales
de
una
aplicación
distribuida
y
enunciaba
el
teorema
de
CAP[8]
Estos
tres
requerimientos
son
Introducción
12
1
Consistencia
todos
los
usuarios
deben
ver
la
misma
versión
de
los
datos
aunque
haya
cambios
en
estos
Éstos
cambios
deben
poder
ser
vistos
por
otros
usuarios
desde
el
mismo
momento
en
el
que
se
hagan
2
Disponibilidad
el
servicio
debe
estar
disponible
y
el
tiempo
de
respuesta
del
vicio
debe
ser
bajo
3
Tolerancia
a
particionesfallos
todos
los
usuarios
deberían
ser
capaces
de
acceder
a
todos
los
datos
pese
a
que
en
caso
de
tener
un
cluster
alguno
de
los
nodos
quedase
deshabilitado
El
teorema
de
CAP
dice
que
no
es
posible
mantener
estos
tres
requerimientos
con
un
gran
volumen
de
datos
y
actividad
Con
poca
actividad
o
pocos
datos
es
posible
mantener
la
consistencia
entre
diferentes
nodos
de
un
sistema
distribuido
de
forma
rápida
y
sin
que
afecte
al
resto
de
comunicaciones
En
el
caso
de
que
haya
gran
cantidad
de
actividad
aumentará
la
cantidad
de
información
que
habrá
que
mantener
consistente
Si
esto
ocurre
cuando
únicamente
se
tiene
un
nodo
el
tiempo
empleado
por
el
sistema
en
mantener
la
consistencia
será
bajo
y
los
datos
estarán
disponibles
casi
inmediatamente
Si
se
añaden
muchos
nodos
para
aumentar
la
tolerancia
a
fallos
con
cada
nuevo
nodo
aumentará
el
tiempo
empleado
en
mantener
la
consistencia
con
lo
que
los
datos
tardarán
más
tiempo
en
estar
disponibles
Por
tanto
no
es
posible
tener
consistencia
inmediata
disponibilidad
alta
y
gran
tolerancia
a
fallos
un
gran
número
de
nodos
con
datos
replicados
al
mismo
tiempo
Existen
varias
opciones
a
la
hora
de
tratar
estos
problemas
[8]
y
en
general
las
soluciones
buscan
limitar
alguno
de
los
tres
requisitos


Eliminar
la
tolerancia
a
fallos
sin
nodos
el
tiempo
de
espera
a
que
los
datos
sean
consistentes
es
mínimo

Eliminar
la
alta
disponibilidad
permitiendo
que
haya
retrasos
en
el
tiempo
de
respuesta
derivados
del
tiempo
que
se
tarda
en
mantener
la
consistencia
de
los
datos

Eliminar
la
consistencia
los
datos
serán
consistentes
en
algún
momento
Si
gún
usuario
requiere
algún
dato
se
responderá
sin
esperar
a
que
los
datos
sean
consistentes

BASE
es
un
modelo
de
consistencia
que
consta
de
tres
principios
[9]
Introducción
13
1
Basic
Availability
este
principio
indica
que
los
datos
deben
ser
altamente
disponibles
en
todo
momento
por
lo
que
el
tiempo
de
respuesta
debe
ser
bajo
y
el
sistema
debe
ser
tolerante
a
fallos
2
Soft
State
indica
que
el
estado
de
los
datos
puede
cambiar
de
repente
debido
al
tercer
principio
3
Eventual
Consistency
asegura
que
en
algún
momento
los
datos
en
todos
los
nodos
serán
consistentes
con
los
cambios
hechos
Sin
embargo
la
consistencia
no
tiene
que
ser
inmediata
1322
Tipos
de
bases
de
datos
NoSQL
Es
posible
dividir
los
tipos
de
bases
de
datos
en
función
del
modelo
de
datos
que
utilizan
Entre
ellos
existen
cuatro
modelos
principales
Documentales
Cada
objeto
esta
representado
por
documentos
Estos
documentos
son
estructuras
de
datos
complejas
formadas
por
un
conjunto
de
campos
y
sus
valores
los
cuales
pueden
ser
tanto
datos
simples
como
subdocumentos
subestructuras
de
datos
mente
son
buenas
para
almacenar
representaciones
de
un
objeto
como
es
el
caso
de
los
artículos
de
una
tienda
que
pueden
tener
distintos
tipos
de
productos
Figura
16
Sistema
de
Bases
de
Datos
Basado
en
Documentos
Introducción
14
Grafos
Generalmente
se
representan
con
unas
estructuras
de
datos
llamadas
tripletas
Estas
tripletas
contienen
tres
valores
los
cuales
representan
a
dos
nodos
y
a
la
relación
que
existe
entre
ellos
Generalmente
se
usan
para
representar
datos
altamente
dos
como
grafos
sociales
con
información
de
las
relaciones
entre
personas
Figura
17
Sistema
de
Bases
de
Datos
Basado
en
Grafos
Son
las
más
simples
los
elementos
son
guardados
en
la
base
de
datos
como
una
clave
que
será
el
nombre
de
un
atributo
y
su
valor
Cada
objeto
está
representado
por
un
conjunto
de
pares
Generalmente
son
buenas
obteniendo
rápidamente
el
valor
de
una
clave
determinada
Por
ejemplo
Amazon
utiliza
este
tipo
de
base
de
datos
para
implementar
la
cesta
de
la
compra
Figura
18
Sistema
de
Bases
de
Datos
Basado
en
Introducción
15
Familia
de
columnas
Estas
bases
de
datos
se
pueden
ver
como
una
evolución
de
las
bases
de
datos
valor
donde
el
valor
puede
ser
un
dato
o
un
conjunto
de
columnas
En
estas
bases
de
datos
la
estructura
más
básica
es
una
columna
que
está
formada
por
una
clave
y
un
valor
simple
Después
una
estructura
algo
más
compleja
son
las
supercolumnas
que
contienen
un
conjunto
de
columnas
Por
último
las
familias
de
columnas
son
un
conjunto
de
filas
las
cuales
pueden
estar
formadas
por
un
conjunto
de
columnas
yo
supercolumnas
Estas
últimas
forman
la
estructura
principal
de
las
base
datos
es
decir
una
base
de
datos
estará
formada
por
un
conjunto
de
columnas
Además
como
ocurre
con
las
bases
de
datos
de
en
general
las
búsquedas
se
realizan
sobre
las
claves
Figura
19
Sistema
de
Bases
de
Datos
Basado
en
Familia
de
columnas
133
Porqué
NoSQL
Como
se
ha
comentado
en
los
puntos
anteriores
las
bases
de
datos
NoSQL
tienen
una
cierta
ventaja
sobre
las
bases
de
datos
relacionales
cuando
la
cantidad
de
datos
nados
es
grande
si
los
datos
son
muy
complejos
o
si
están
altamente
relacionados
Sin
embargo
no
todo
son
ventajas
Por
un
lado
los
sistemas
no
relacionales
en
general
no
cumplen
el
principio
ACID
y
no
permiten
el
uso
de
transacciones
para
controlar
la
concurrencia
Si
bien
algunos
permiten
ésto
éstos
pueden
tener
problemas
al
escalar
los
datos
entre
varios
ordenadores
tal
y
como
ocurre
con
los
sistemas
relacionales[6]
Introducción
16
Por
otro
lado
las
bases
de
datos
no
relacionales
no
están
estandarizadas
A
diferencia
de
los
sistemas
relacionales
donde
es
posible
aprender
los
conceptos
básicos
del
modelo
relacional
y
aplicarlo
a
los
diferentes
sistemas[2]
Por
tanto
a
pesar
de
estas
desventajas
Porqué
NoSQL
La
realidad
es
que
la
pregunta
no
debería
ser
porqué
sino
cuándo
Un
sistema
NoSQL
no
va
a
sustituir
a
uno
relacional
cuando
se
requiera
una
gran
tencia
Por
ejemplo
en
un
banco
al
realizar
transferencias
se
querrá
que
las
operaciones
sean
consistentes
con
lo
que
un
sistema
NoSQL
podría
generar
problemas
que
uno
cional
no
generará
Por
tanto
un
sistema
no
relacional
sería
más
adecuado
aunque
puediera
resultar
algo
más
lento
Pero
no
siempre
se
quiere
que
la
base
de
datos
sea
consistente
Por
ejemplo
puede
ser
el
caso
de
una
aplicación
que
requiera
la
búsqueda
de
artículos
en
una
página
de
noticias
con
gran
número
de
noticias
En
este
caso
es
probable
que
se
prefiera
que
las
búsquedas
sean
más
rápidas
aunque
no
muestren
el
artículo
que
se
creó
hace
un
segundo
Si
el
número
de
artículos
es
lo
suficientemente
grande
o
si
los
datos
son
muy
complejos
un
sistema
NoSQL
sería
más
adecuado
Por
tanto
no
es
una
cuestión
de
sistemas
relacionales
vs
sistemas
NoSQL
Estos
dos
pueden
coexistir
ya
que
cada
uno
resuelve
distintos
problemas
[2]
y
por
tanto
serán
adecuados
para
distintas
tareas
14
Planificación
En
esta
sección
se
explican
los
diferentes
aspectos
que
se
han
tenido
en
cuenta
a
la
hora
de
planificar
el
desarrollo
del
proyecto
así
como
el
análisis
de
alcance
mínimo
y
de
la
ampliación
del
alcance
141
Alcance
En
los
siguientes
apartados
se
explica
el
alcance
mínimo
que
deberá
tener
el
diseño
del
entorno
trabajo
y
la
aplicación
a
desarrollar
así
como
la
ampliación
del
alcance
que
se
plantea
en
caso
de
disponer
de
tiempo
tras
realizar
el
alcance
mínimo
y
otros
aspectos
de
la
planificación
relacionados
con
el
alcance
Introducción
17
1411
Alcance
mínimo
En
las
siguientes
secciones
se
especifica
el
alcance
mínimo
que
deben
cumplir
cada
uno
de
los
objetivos
mencionados
anteriormente
14111
Aplicación
de
persistencia
políglota
La
idea
de
una
aplicación
que
gestione
una
persistencia
políglota
es
la
de
crear
una
API
la
cual
deberá
permitir
a
los
usuarios
conectarse
a
tres
sistemas
de
bases
de
datos
–
MongoDB
OpenLink
Virtuoso
MySQL
y
realizar
operaciones
sobre
los
mismos
de
forma
transparente
es
decir
sin
que
tenga
que
preocuparse
de
las
características
específicas
de
cada
uno
de
ellos
Con
la
idea
de
acercase
a
un
ejemplo
del
mundo
real
en
el
que
una
misma
aplicación
pudiera
beneficiarse
del
uso
de
diferentes
sistemas
de
bases
de
datos
para
realizar
distintas
tareas
se
ha
decidido
implementar
una
aplicación
en
el
dominio
del
comercio
electrónico
La
aplicación
cuenta
con
los
siguientes
servicios
de
los
que
se
encargarán
los
distintos
sistemas

Bussiness
Intelligent
este
servicio
permitirá
mostrar
anuncios
personalizados
a
un
cliente
dado
en
función
de
las
preferencias
de
otros
clientes
que
tengan
gustos
similares
Para
este
servicio
se
utilizará
OpenLink
Virtuoso
el
cual
usará
datos
rdf

Manejo
de
contenido
este
servicio
es
el
que
mostrará
los
artículos
y
realizará
las
búsquedas
solicitadas
por
los
clientes
Para
este
servicio
se
utilizará
MongoDB

Carro
de
la
Compra
este
servicio
es
el
que
permitirá
tener
guardados
artículos
temporalmente
en
la
lista
de
la
compra
Para
este
servicio
también
se
utilizará
MongoDB
aunque
los
datos
solo
serán
guardados
durante
un
tiempo
y
luego
rarán

Inventario
este
servicio
es
el
que
se
encargará
de
controlar
la
cantidad
de
artículos
disponibles
para
evitar
que
un
cliente
compre
algún
artículo
para
el
cual
no
existan
unidades
disponibles
Para
este
servicio
se
utilizará
MySQL
Además
puesto
que
se
quiere
hacer
esto
con
una
gran
carga
de
datos
se
creará
un
dataset
artificial
para
cada
sistema
cuyo
modelo
de
datos
se
ajuste
a
las
necesidades
de
cada
uno
de
los
servicios
Introducción
18
14112
Diseño
del
entorno
de
trabajo
Se
realizará
un
diseño
del
entorno
de
trabajo
básico
sobre
dos
sistemas
de
bases
de
datos
NoSQL
en
particular
MongoDB
y
OpenLink
Vistuoso
Para
cada
sistema
se
deberán
tratar
como
mínimo
los
siguientes
aspectos

Instalación
del
sistema
de
base
de
datos

Modelado
de
datos
e
importación
de
estos

Alguna
operacion
de
administración
como
realizar
volcados
y
cargas
de
datos
o
configurar
el
sistema
para
mejorar
el
rendimiento

Diseño
de
Queries
para
realizar
consultas
en
el
lenguaje
que
utilice
cada
sistema
y
pruebas
para
ver
el
rendimiento
de
los
diferentes
tipos
de
operaciones
sobre
cada
base
de
datos

Estudio
de
las
opciones
de
concurrencia
que
ofrece
cada
sistema

Diseño
de
índices
para
mejorar
el
rendimiento
de
las
consultas

Gestión
de
seudotransacciones
1412
Ampliación
del
alcance
En
caso
de
que
fuera
posible
tras
realizar
el
alcance
mínimo
se
propone
la
realización
de
las
siguientes
ampliaciones

Diseño
de
un
sistema
distribuido
en
MongoDB
que
incluya
replicación
sharding
yo
diseño
de
operaciones
de
tipo
map
reduce

Diseño
de
un
sistema
distribuido
en
OpenLink
Virtuoso
que
incluya
replicación
sharding
yo
diseño
de
operaciones
de
tipo
mapreduce
1413
Criterios
de
aceptación
Se
considerará
que
el
proyecto
cumple
con
los
criterios
de
aceptación
cuando
el
proyecto
cumpla
el
alcance
mínimo
planteado
anteriormente
y
haya
sido
revisado
y
aprobado
por
el
director
del
proyecto
Introducción
19
1414
Exclusiones
del
alcance
En
lo
que
se
refiere
a
las
tareas
de
la
ampliación
del
alcance
se
ha
considerado
aumentar
el
diseño
del
entorno
para
que
incluya
aspectos
relacionados
con
el
despliegue
de
bases
de
datos
distribuidas
sin
embargo
queda
fuera
del
alcance
el
incluir
en
la
aplicación
que
gestiona
una
persistencia
políglota
las
operaciones
relacionadas
con
dichos
sistemas
distribuidos
Así
mismo
puesto
que
el
objetivo
principal
de
la
aplicación
a
desarrollar
es
el
estudio
de
las
aplicaciones
de
persistencia
políglota
se
excluye
del
alcance
el
mentar
servicios
no
relacionados
con
los
indicados
en
el
alcance
mínimo
como
pueden
ser
servicios
de
pagos
reales
142
Entregables
del
proyecto
La
realización
del
proyecto
incluye
los
siguientes
entregables
1
Memoria
documento
que
contenga
información
sobre
lo
realizado
durante
el
proyecto
2
Instancias
de
las
base
de
datos
sobre
las
que
se
permita
realizar
pruebas
3
Documentación
con
el
diseño
del
sistema
pasos
que
se
han
seguido
y
resultados
de
las
distintas
pruebas
realizadas
4
Intancia
de
la
aplicación
en
funcionamiento
5
Código
fuente
de
la
aplicación
realizada
143
Esquema
de
desglose
de
trabajo
Seguidamente
se
muestra
el
esquema
de
desglose
de
trabajo
110
en
el
cual
se
plasman
los
diferentes
paquetes
de
tareas
en
los
que
se
ha
descompuesto
el
proyecto
Dicho
esquema
se
ha
dividido
en
cinco
tareas
generales
–
planificación
gestión
formación
desarrollo
y
documentación
–
las
cuales
a
su
vez
se
han
dividido
en
tareas
más
concretas
Introducción
20
Figura
110
Esquema
de
desglose
de
trabajo
144
Planificación
temporal
Seguidamente
se
muestra
el
tiempo
necesario
que
se
estima
se
tardará
en
realizar
las
diferentes
tareas
que
componen
el
proyecto
así
como
la
lista
de
hitos
más
importantes
y
las
fechas
en
las
que
se
prevé
que
se
llevarán
a
cabo
Por
último
también
se
incluye
un
cronograma
con
las
fechas
durante
las
cuales
se
planea
realizar
cada
tarea
1441
Actividades
Seguidamente
se
muestran
las
tablas
con
la
información
de
las
horas
que
se
planea
invertir
en
cada
una
de
las
tareas
a
realizar
La
tabla
11
muestra
la
planificación
del
paquete
de
tareas
Planificación
el
cual
recoge
tareas
relacionadas
con
la
planificación
del
desarrollo
del
proyecto
Planificación
Tiempo
estimado
Planificación
inicial
16h
Análisis
de
requisistos
8h
Plan
de
gestión
8h
Replanificaciones
7h
Total
23h
Tabla
11
Tiempo
de
planificación
estimado
Introducción
21
La
tabla
12
correspondiente
al
paquete
de
gestión
muestra
la
estimación
del
tiempo
que
se
tardará
en
realizar
las
tareas
relacionadas
con
el
control
del
progreso
del
proyecto
Gestión
Tiempo
estimado
Análisis
de
la
ampliación
3h
Seguimiento
y
Control
22h
Reuniones
10h
Total
35h
Tabla
12
Tiempo
de
getión
estimado
La
tabla
13
muestra
información
sobre
el
tiempo
que
se
estima
que
el
desarrollador
tardará
en
formarse
en
las
diferentes
tecnologías
a
usar
de
las
que
no
se
tenga
previo
conocimiento
Concretamente
el
punto
Formación
para
realizar
la
aplicación
se
refiere
a
la
ción
sobre
aplicaciones
de
persistencia
políglota
y
en
menor
medida
a
la
formación
en
tecnologías
para
implementar
la
aplicación
Esto
último
es
debido
a
que
se
prevé
que
la
formación
en
herramientas
para
el
desarrollo
de
la
capa
de
presentación
de
la
aplicación
será
mínima
puesto
que
se
ha
tenido
contacto
con
el
desarrollo
de
páginas
web
en
varias
asignaturas
Por
otro
lado
así
mismo
ocurre
con
el
lenguaje
–
java
elegido
para
desarrollar
el
resto
de
la
aplicación
del
cual
se
ha
tenido
un
extenso
contacto
durante
los
pasados
años
en
especial
en
la
asignatura
de
programación
concurrente
e
ingeniería
del
software
Formación
Tiempo
estimado
Formación
en
NoSQL
general
10h
Formación
en
MongoDB
básico
30h
Formación
en
OpenLink
Virtuoso
básico
30h
Formación
para
realizar
la
Aplicación
10h
Total
80h
Tabla
13
Tiempo
de
formación
estimado
La
tabla
14
recoge
información
sobre
el
tiempo
que
se
estima
se
tardará
en
desarrollar
el
diseño
y
la
aplicación
con
las
especificaciones
indicadas
en
el
alcance
mínimo
Además
Introducción
22
por
cada
punto
se
especifica
el
tiempo
que
se
tardará
en
diseñar
implementar
y
realizar
las
pruebas
Por
otro
lado
en
esta
tabla
también
se
incluye
el
tiempo
que
se
empleará
en
realizar
los
backups
de
las
bases
de
datos
para
evitar
la
pérdida
del
trabajo
en
caso
de
problemas
Desarrollo
Tiempo
estimado
Backups
de
las
BD
5h
Desarrollo
MongoDB
30h
Diseño
del
entorno
MongoDB
15h
Implementación
de
operaciones
MongoDB
10h
Pruebas
de
rendimiento
MongoDB
5h
Desarrollo
OpenLink
Virtuoso
30h
Diseño
del
entorno
OpenLink
Virtuoso
15h
Implementación
de
operaciones
OpenLink
Virtuoso
10h
Pruebas
de
rendimiento
OpenLink
Virtuoso
5h
Desarrollo
de
la
aplicación
115h
Diseño
25h
Implementación
65h
Pruebas
15h
Total
170h
Tabla
14
Tiempo
de
desarrollo
estimado
Finalmente
la
tabla
15
muestra
el
tiempo
que
se
estima
se
tardará
en
realizar
las
tareas
de
documentación
tanto
de
la
memoria
del
proyecto
como
de
la
documentación
del
diseño
del
entorno
de
trabajo
sobre
las
diferentes
bases
de
datos
Documentación
Tiempo
estimado
Memoria
40h
Revisiones
10h
Defensa
10h
Documentación
del
diseño
25h
Total
85h
Tabla
15
Tiempo
de
documentación
estimado
Introducción
23
El
tiempo
total
que
se
estima
se
tardará
en
realizar
el
proyecto
para
el
alcance
mínimo
es
de
393
horas
1442
Actividades
de
la
ampliación
Seguidamente
se
muestra
en
la
tabla
16
una
estimación
de
lo
que
se
cree
debería
tardase
en
realizar
la
ampliación
del
alcance
Hay
que
tener
en
cuenta
que
este
tiempo
viene
condicionado
por
el
tiempo
que
se
prevé
que
habrá
disponible
tras
realizar
el
alcance
mínimo
Por
tanto
será
necesario
durante
el
análisis
de
ampliación
obtener
más
mación
sobre
las
tareas
que
se
deben
realizar
y
recalcular
los
tiempos
para
ver
si
la
ampliación
es
viable
con
el
tiempo
disponible
real
Ampliación
Tiempo
estimado
Formación
Amazon
EC2
10h
MongoDB
55h
Replicación
20h
Sharding
20h
Mapreduce
10h
Documentación
5h
Openlink
Virtuoso
55h
Replicación
20h
Sharding
20h
Mapreduce
10h
Documentación
5h
Tabla
16
Estimación
del
tiempo
de
la
ampliación
1443
Hitos
Seguidamente
se
muestra
la
tabla
17
con
los
hitos
más
importantes
junto
a
la
fecha
en
la
que
se
deberían
dar
Introducción
24
Hitos
Fecha
del
Hito
Planificación
inicial
15072013
Diseño
MongoDB
básico
29072013
Análisis
de
la
viabilidad
del
proyecto
29072013
Diseño
OpenLink
Virtuoso
básico
22082013
Prototipo
de
la
aplicación
16092013
Finalización
de
la
aplicación
30092013
Análisis
de
ampliación
30092013
Borrador
de
la
memoria
18112013
Finalización
de
los
entregables
02122013
Finalización
del
proyecto
15012014
Tabla
17
Fecha
de
Hitos
145
Cronograma
Seguidamente
se
muestra
un
cronograma
111
el
cual
especifica
las
fechas
durante
las
cuales
se
espera
realizar
cada
una
de
las
tareas
indicadas
en
los
apartados
anteriores
Hay
que
destacar
que
en
el
cronograma
entre
las
fechas
del
17
de
septiembre
y
el
4
de
noviembre
únicamente
se
realizan
tareas
de
seguimiento
y
control
y
la
revisión
del
documento
de
los
diseños
de
desarrollo
Esto
se
debe
a
que
se
han
dejado
esas
fechas
libres
por
un
lado
con
la
intención
de
que
sirvan
de
holgura
en
caso
de
que
haya
problemas
durante
la
realización
de
las
tareas
del
alcance
mínimo
y
por
otro
lado
para
que
en
caso
de
decidir
realizar
la
ampliación
del
alcance
tener
tiempo
extra
para
que
su
realización
sea
posible
146
Costes
Durante
la
realización
del
alcance
mínimo
se
planea
realizar
las
tareas
que
conforman
el
proyecto
con
herramientas
de
libre
uso
En
concreto
para
los
sistemas
de
bases
de
datos
utilizadas
se
planea
utilizar
las
versiones
de
libre
uso
y
no
las
versiones
de
pago
de
estos
sistemas
Por
tanto
el
coste
estimado
del
alcance
mínimo
es
de
cero
euros
Por
otro
lado
en
caso
de
realizar
las
tareas
presentes
en
la
ampliación
del
alcance
se
ha
pensado
en
usar
servicios
similares
a
Amazon
EC2
para
poder
desplegar
el
sistema
distribuido
Puesto
que
estos
servicios
son
normalmente
de
pago
esto
podría
conllevar
un
cierto
gasto
En
cualquier
caso
el
coste
de
dicho
servicio
se
calculará
al
realizar
el
análisis
de
ampliación
para
ver
si
la
realización
de
las
tareas
de
ampliación
es
viable
Introducción
25
F
ig
u
r
a
1
11

C
ro
no
gr
am
a
Introducción
26
147
Análisis
de
calidad
Para
mantener
la
calidad
a
lo
largo
del
proyecto
una
de
las
principales
tareas
que
se
ha
programado
es
la
de
mantener
reuniones
con
el
director
del
proyecto
una
vez
cada
dos
semanas
para
comprobar
que
lo
realizado
durante
el
proyecto
se
adecua
a
lo
esperado
inicialmente
En
las
siguientes
secciones
se
indica
una
planificación
más
concreta
para
mantener
la
calidad
por
un
lado
del
proyecto
y
por
otro
la
calidad
del
producto
1471
Calidad
del
proyecto
Para
mantener
la
calidad
en
lo
referente
al
proyecto
se
han
planeado
las
siguientes
tuaciones

Para
asegurar
que
el
proyecto
se
lleva
a
cabo
según
lo
indicado
en
la
planificación
habrá
un
día
a
la
semana
en
el
que
se
analizarán
las
tareas
realizadas
durante
la
semana
y
se
replanificará
si
fuese
necesario
Todo
esto
como
parte
de
las
tareas
del
seguimiento
y
control

Se
ha
establecido
un
política
de
replicación
de
documentos
en
varios
sistemas
de
almacenamiento
tanto
online
como
offline
lo
cual
permitirá
que
en
caso
de
perder
los
datos
en
una
de
las
bases
de
datos
esto
no
provocará
la
pérdida
de
más
de
un
día
de
trabajo
en
el
peor
de
los
casos
1472
Calidad
de
los
entregables
En
lo
referente
a
los
entregables
se
han
planificado
las
siguientes
medidas

En
lo
que
se
refiere
a
la
documentación
del
diseño
se
ha
planificado
la
entrega
al
terminar
dicho
diseño
y
se
ha
planificado
tiempo
de
holgura
para
poder
realizar
cambios
en
la
documentación
si
fuera
necesario

En
lo
que
se
refiere
a
la
aplicación
se
ha
planificado
la
presentación
al
director
del
proyecto
de
un
prototipo
para
comprobar
que
cumple
con
los
requisitos
solicitados

Para
la
calidad
de
la
memoria
del
proyecto
se
ha
incluido
en
la
planificación
una
tarea
de
revisión
y
corrección
la
cual
al
igual
que
en
el
caso
anterior
se
ha
planeado
con
un
cierto
margen
a
la
entrega
final
de
los
entregables
Introducción
27
148
Comunicaciones
Para
mantener
una
comunicación
con
los
diferentes
interesados
del
proyecto
se
han
señado
la
política
de
comunicación
que
se
muestra
en
los
siguientes
apartados
en
los
que
se
detalla
quienes
son
los
interesados
el
método
de
comunicación
y
reuniones
a
llevar
a
cabo
1481
Política
de
comunicación
Principalmente
los
interesados
de
este
proyecto
son

Directora
Arantza
Illarramendi
Echave

Desarrollador
Estefanía
Gutiérrez
La
comunicación
entre
los
dos
interesados
anteriores
se
realizará
mediante
el
envío
de
correos
electrónicos
o
en
casos
de
urgencia
mediante
comunicación
telefónica
o
en
sona
1482
Reuniones
Para
ayudar
a
mantener
la
calidad
del
proyecto
y
como
parte
de
las
tareas
de
seguimiento
y
control
se
ha
planeado
celebrar
reuniones
entre
los
dos
interesados
con
un
intervalo
de
tiempo
entre
dos
semanas
y
una
semana
y
media
149
Gestión
de
riesgos
A
continuación
se
lista
los
riegos
que
se
han
identificado
los
cuales
podrían
afectar
al
desarrollo
e
integridad
del
proyecto
así
como
las
soluciones
que
se
plantean
en
caso
de
que
se
dieran
dichos
riesgos
No
cumplimiento
de
los
plazos
de
entrega
Gravedad
Muy
alta
Probabilidad
Baja
Medidas
preventivas
principalmente
se
han
planificado
con
tiempo
las
fechas
entre
las
que
se
planea
realizar
las
tareas
del
alcance
mínimo
y
la
fecha
de
entrega
de
los
entregables
Introducción
28
Medidas
correctoras
no
se
han
planificados
fines
de
semana
como
tiempo
de
trabajo
por
lo
que
sería
posible
añadir
dichas
fechas
como
tiempo
de
trabajo
si
resultase
sario
así
como
ampliar
las
horas
de
trabajo
diarias
Retrasos
Gravedad
media
Probabilidad
alta
Medidas
preventivas
se
han
planificado
las
fechas
con
un
cierto
margen
de
holgura
Medidas
correctoras
aumentar
el
número
de
horas
diario
que
se
estaba
empleando
en
ese
momento
Planificación
inadecuada
Gravedad
media
Probabilidad
alta
Medidas
preventivas
se
ha
planificado
un
tiempo
de
replanificación
así
como
un
hito
durante
el
alcance
mínimo
para
replanificar
el
proyecto
en
caso
de
que
no
se
haya
realizado
adecuadamente
la
fase
anterior
Requisitos
recogidos
inadecuadamente
Gravedad
alta
Probabilidad
Medidas
preventivas
se
han
planificado
reuniones
para
comprobar
que
lo
realizado
es
acorde
con
lo
establecido
inicialmente
por
el
director
Medidas
correctoras
replanificar
Perdida
de
información
y
trabajo
realizado
Gravedad
alta
Probabilidad
baja
Introducción
29
Medidas
preventivas
se
ha
planificado
una
política
de
backups
cada
cierto
tiempo
así
como
la
replicación
de
los
documentos
en
varios
sistemas
de
almacenamiento
Pérdida
de
las
herramientas
de
trabajo
Gravedad
alta
Probabilidad
baja
Medidas
preventivas
se
estará
trabajando
desde
la
universidad
por
lo
que
en
caso
de
pérdida
de
alguna
de
las
herramientas
se
puede
recurrir
a
alguno
de
los
ordenadores
disponibles
En
lo
referente
a
los
datos
que
se
puedan
perder
al
igual
que
en
los
casos
anteriores
este
problema
se
solucionaría
con
la
replicación
y
backup
de
los
datos
Enfermedad
Gravedad
baja
Probabilidad
baja
Medidas
preventivas
el
entorno
de
trabajo
desde
el
que
se
realiza
el
proyecto
permitirá
realizar
tareas
desde
el
domicilio
del
desarrollador
Esto
solo
soluciona
el
problema
en
caso
de
enfermedad
leve
Para
otros
casos
véase
la
solución
propuesta
en
el
apartado
de
retrasos
Capítulo
2
Entorno
de
Trabajo
bajo
MongoDB
y
OpenLink
Virtuoso
La
Aplicación
de
Persistencia
Políglota
de
este
proyecto
utilizará
tres
sistemas
de
cenamiento
En
concreto
se
han
utilizado
dos
sistemas
NoSQL
y
uno
relacional
En
lo
que
se
refiere
a
los
sistemas
NoSQL
se
han
usado
de
dos
tipos
1
un
sistema
de
mentos
y
2
un
sistema
de
grafos
En
concreto
las
tecnologías
de
almacenamiento
usadas
han
sido
MongoDB
para
documentos
Openlink
Virtuoso
para
grafos
y
MySQL
como
sistema
relacional
En
este
capítulo
se
van
a
dar
información
sobre
las
características
principales
y
el
funcionamiento
de
los
sistemas
MongoDB
y
OpenLink
Virtuoso
21
MongoDB
MongoDB
[13]
es
un
sistema
de
bases
de
datos
basado
en
documentos
que
ofrece
alta
eficiencia
Este
sistema
guarda
los
datos
en
documentos
que
internamente
son
objetos
BSON
los
cuales
son
muy
similares
a
los
objetos
JSON
Éstos
documentos
se
guardan
dentro
de
colecciones
formando
algo
similar
a
una
tabla
en
un
sistema
relacional
A
su
vez
un
conjunto
de
colecciones
forman
una
base
de
datos
Una
de
las
características
presentes
en
los
documento
es
que
permiten
diseñar
esquemas
muy
complejos
En
estos
esquemas
es
posible
tener
subestructuras
llamadas
mentos
que
se
asignan
como
valor
de
uno
de
los
campos
de
un
documento
Con
esto
se
pueden
representar
objetos
que
tengan
varios
niveles
de
anidación
Por
otro
lado
al
igual
que
ocurre
con
otros
sistemas
como
los
relacionales
es
posible
guardar
una
gran
variedad
de
tipos
de
datos
como
enteros
reales
fechas
Pero
destaca
el
hecho
de
que
30
Entorno
de
Trabajo
bajo
MongoDB
y
OpenLink
Virtuoso
31
es
posible
guardar
listas
de
elementos
en
un
sólo
campo
incluyendo
listas
de
mentos
Otra
característica
interesante
de
los
documentos
es
que
los
documentos
de
una
colección
puede
tener
diferentes
esquemas
unos
de
otros
Todo
esto
permite
modelar
los
datos
de
forma
similar
a
como
se
guardarían
en
los
objetos
de
una
aplicación
con
lo
que
se
consigue
que
haya
una
cierta
homogeneidad
entre
ambos
En
lo
que
se
refiere
a
la
estructura
de
este
tipo
de
sistemas
en
cierto
modo
se
puede
considerar
que
la
estructura
de
las
bases
de
datos
es
similar
a
la
que
se
puede
encontrar
en
Sistemas
de
Bases
de
Datos
Relacionales
SBDR
El
sistema
esta
formado
por
un
servidor
el
cual
gestiona
las
bases
de
datos
que
guardan
los
datos
y
realiza
operaciones
sobre
los
datos
en
función
de
las
consultas
que
los
usuarios
le
soliciten
Los
datos
al
igual
que
ocurre
con
los
sistemas
SBDR
se
organizan
en
bases
de
datos
creadas
por
los
usuarios
y
en
éstas
se
guardan
los
datos
con
el
esquema
deseado
Dentro
de
estas
bases
de
datos
se
encuentran
las
colecciones
que
se
podrían
considerar
son
semejantes
a
las
tablas
de
las
bases
de
datos
relacionales
Dentro
de
estas
colecciones
se
encuentran
los
llamados
documentos
Estos
documentos
equivaldrían
a
las
tuplas
de
las
bases
de
datos
principalmente
porque
ambos
contienen
campos
con
valores
en
ellos
Sin
embargo
la
estructura
es
completamente
diferente
Mientras
que
en
las
tablas
los
campos
son
fijos
para
todas
las
tuplas
y
estos
contienen
datos
simples
en
las
colecciones
puede
haber
un
documento
con
campos
que
otro
no
tiene
y
los
campos
pueden
contener
subdocumentos
con
sus
propios
campos
Esto
hace
que
el
esquema
de
un
objeto
complejo
que
puede
tener
distintas
propiedades
en
función
del
tipo
de
objeto
y
que
en
una
base
de
datos
relacional
requeriría
múltiples
tablas
relacionadas
entre
ellas
en
MongoDB
se
pueda
solucionar
con
una
única
colección
donde
los
documentos
pueden
tener
distintos
esquemas
y
se
pueden
ajustar
a
las
propiedades
que
tenga
cada
objeto
Por
otro
lado
como
es
común
en
muchos
sistemas
NoSQL
MongoDB
no
soporta
el
uso
de
JOINS
Sin
embargo
soporta
el
uso
de
índices
y
el
uso
de
instrucciones
atómicas
a
nivel
del
documento
Tampoco
soporta
SQL
ni
lenguajes
similares
como
SPARQL
en
su
lugar
monogDB
implementa
una
serie
de
métodos
que
permiten
realizar
operaciones
consultas
sobre
los
documentos
colecciones
y
las
bases
de
datos
así
como
sobre
el
mismo
servidor
Además
incluye
un
entorno
de
trabajo
en
JavaScript
el
cual
permite
valerse
de
las
características
de
dicho
lenguaje
para
facilitar
la
realización
de
las
consultas
y
operaciones
que
se
hagan
sobre
la
base
de
datos
En
lo
que
se
refiere
al
sistema
en
si
las
principales
características
que
presenta
son

Índices
es
posible
crear
índices
sobre
varios
campos
tanto
de
los
documentos
como
de
los
subdocumentos
y
también
es
posible
indexar
los
campos
de
tipo
array
Entorno
de
Trabajo
bajo
MongoDB
y
OpenLink
Virtuoso
32
La
única
restricción
es
que
no
permite
indexar
dos
campos
de
tipo
array
sobre
el
mismo
índice

Consultas
no
es
posible
utilizar
lenguajes
como
SQL
para
realizar
las
consultas
sino
que
MongoDB
ofrece
una
serie
de
instrucciones
propias
que
permiten
realizar
las
consultas
sobre
las
bases
de
datos

Agregación
además
de
las
instrucciones
anteriores
MongoDB
también
ofrece
una
serie
de
instrucciones
y
operadores
equivalentes
en
cierto
modo
a
las
funciones
de
agregación
de
SQL
las
cuales
permiten
realizar
modificaciones
sobre
los
resultados
antes
de
devolverlos

es
posible
realizar
una
serie
de
consultas
especiales
que
permiten
condensar
grandes
cantidades
de
datos
en
resultados
agregados
Además
MongoDB
ofrece
una
serie
de
herramientas
entre
las
que
se
encuentra
1
un
cliente
shell
desde
el
cual
se
pueden
realizar
las
consultas
y
que
soporta
un
lenguaje
similar
a
JavaScript
para
facilitar
la
realización
de
operaciones
2
herramientas
para
realizar
volcados
de
los
datos
y
para
recuperar
los
datos
mongodumpmongoexport
y
mongorestoremongoimport
y
3
una
serie
de
herramientas
de
diagnóstico
como
mongostat
Entre
las
limitaciones
de
MongoDB
hay
que
destacar
que
aunque
ofrece
herramientas
para
realizar
operaciones
atómicas
MongoDB
no
soporta
el
uso
de
transacciones
de
forma
nativa
y
no
cumple
con
los
principios
ACID
Por
último
para
realizar
consultas
a
nivel
de
aplicación
MongoDB
ofrece
drivers
de
forma
oficial
para
una
gran
cantidad
de
lenguajes
como
Java
Python
CC++
Este
driver
permite
conectarse
al
sistema
de
almacenamiento
y
realizar
consultas
sobre
ellos
Una
característica
de
este
driver
es
que
a
diferencia
de
los
drivers
JDBC
los
datos
obtenidos
y
enviados
son
guardados
en
unos
objetos
llamados
DBObject
con
una
estructura
similar
a
los
objetos
JSON
Esto
último
permite
usar
librerías
como
GSON
para
pasar
los
datos
entre
objetos
de
la
aplicación
y
de
la
base
de
datos
de
forma
sencilla
[pag181]
211
Herramientas
La
filosofía
de
MongoDB
es
la
de
ser
una
base
de
datos
de
documentos
básica
sin
añadir
herramientas
que
se
encarguen
de
hacer
tareas
que
otras
herramientas
hacen
mejor
por
ejemplo
en
el
caso
del
manejo
de
memoria
MongoDB
considera
que
es
mejor
que
el
sistema
operativo
se
encargue
de
su
manejo
Por
tanto
todas
las
herramientas
que
provee
este
sistema
están
orientadas
a
esta
tarea
Entorno
de
Trabajo
bajo
MongoDB
y
OpenLink
Virtuoso
33
Las
principales
herramientas
son
las
siguientes

mongod
es
la
instacia
principal
del
sistema
y
es
el
que
se
encarga
de
procesar
las
consultas
y
realizar
tareas
sobre
los
datos
En
general
esta
instancia
guarda
los
datos
en
el
directorio
datadb

mongo
es
la
interfaz
que
MongoDB
incluye
en
el
paquete
de
instalación
para
que
el
usuario
pueda
comunicarse
con
la
instancia
del
servidor
Este
interfaz
es
una
herramienta
de
trabajo
basada
en
JavaScript
y
que
permite
realizar
operaciones
y
consultas
sobre
los
datos
así
como
administrar
las
bases
de
datos
utilizando
para
ello
una
serie
de
métodos
ya
implementados
Además
permite
al
usuario
valerse
del
lenguaje
JavaScript
para
facilitar
la
realización
de
las
diferentes
operaciones

mongorestoremongodump
estas
dos
herramientas
permiten
por
un
lado
realizar
volcados
de
los
datos
que
hay
en
el
sistema
a
nivel
tanto
de
base
de
datos
como
de
colección
y
por
otro
recuperar
los
datos
volcados
con
anterioridad

Driver
existen
drivers
oficiales
para
diversos
lenguajes
de
programción
como
C++
Java
Python
Ruby
Nodejs
Pero
además
existen
drivers
mantenidos
por
la
comunidad
de
usuarios
para
los
lenguajes
no
soportados
de
forma
oficial
212
Formato
de
los
datos
En
MongoDB
como
se
ha
dicho
anteriormente
los
datos
se
guardan
en
documentos
Estos
documentos
son
guardados
en
el
sistema
con
un
formato
llamado
BSON
el
cual
es
si